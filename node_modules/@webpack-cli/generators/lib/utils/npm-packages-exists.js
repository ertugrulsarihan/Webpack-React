"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.npmPackagesExists = exports.npmExists = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const colorette_1 = require("colorette");
const path_utils_1 = require("./path-utils");
const resolve_packages_1 = require("./resolve-packages");
const global_packages_path_1 = require("./global-packages-path");
const WEBPACK_SCAFFOLD_PREFIX = 'webpack-scaffold';
const got_1 = __importDefault(require("got"));
// TODO: to understand the type
// eslint-disable-next-line
const constant = (value) => (res) => value;
/**
 *
 * Checks if the given dependency/module is registered on npm
 *
 * @param {String} moduleName - The dependency to be checked
 * @returns {Promise} constant - Returns either true or false,
 * based on if it exists or not
 */
// TODO: figure out the correct type here
// eslint-disable-next-line
function npmExists(moduleName) {
    const hostname = 'https://www.npmjs.org';
    const pkgUrl = `${hostname}/package/${moduleName}`;
    return got_1.default(pkgUrl, {
        method: 'HEAD',
    })
        .then(constant(true))
        .catch(constant(false));
}
exports.npmExists = npmExists;
/**
 *
 * Loops through an array and checks if a package is registered
 * on npm and throws an error if it is not.
 *
 * @param {String[]} pkg - Array of packages to check existence of
 * @returns {Array} resolvePackages - Returns a process to install the packages
 */
function npmPackagesExists(pkg) {
    const acceptedPackages = [];
    function resolvePackagesIfReady() {
        if (acceptedPackages.length === pkg.length) {
            return resolve_packages_1.resolvePackages(acceptedPackages);
        }
    }
    pkg.forEach((scaffold) => {
        if (path_utils_1.isLocalPath(scaffold)) {
            // If the scaffold is a path to a local folder, no name validation is necessary.
            acceptedPackages.push(scaffold);
            resolvePackagesIfReady();
            return;
        }
        if (fs_1.existsSync(path_1.resolve(global_packages_path_1.getPathToGlobalPackages(), scaffold))) {
            // If scaffold is already installed or is a linked package
            acceptedPackages.push(scaffold);
            resolvePackagesIfReady();
            return;
        }
        // The scaffold is on npm; validate name and existence
        if (scaffold.length <= WEBPACK_SCAFFOLD_PREFIX.length ||
            scaffold.slice(0, WEBPACK_SCAFFOLD_PREFIX.length) !== WEBPACK_SCAFFOLD_PREFIX) {
            throw new TypeError(colorette_1.bold(`${scaffold} isn't a valid name.\n`) +
                colorette_1.red(`\nIt should be prefixed with '${WEBPACK_SCAFFOLD_PREFIX}', but have different suffix.\n`));
        }
        npmExists(scaffold)
            .then((moduleExists) => {
            if (moduleExists) {
                acceptedPackages.push(scaffold);
            }
            else {
                Error.stackTraceLimit = 0;
                throw new TypeError(`Cannot resolve location of package ${scaffold}.`);
            }
        })
            .catch((err) => {
            console.error(err.stack || err);
            process.exit(2);
        })
            .then(resolvePackagesIfReady);
    });
}
exports.npmPackagesExists = npmPackagesExists;
