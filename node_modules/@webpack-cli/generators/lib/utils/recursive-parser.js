"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.recursiveTransform = void 0;
const ast_utils_1 = require("./ast-utils");
const webpack_cli_1 = require("webpack-cli");
const { logger } = webpack_cli_1.utils;
function recursiveTransform(j, ast, key, value, action) {
    if (key === 'topScope') {
        if (Array.isArray(value)) {
            return ast_utils_1.parseTopScope(j, ast, value, action);
        }
        logger.error('Error in parsing top scope, Array required');
        return false;
    }
    else if (key === 'merge') {
        if (Array.isArray(value)) {
            return ast_utils_1.parseMerge(j, ast, value, action);
        }
    }
    const node = ast_utils_1.findRootNodesByName(j, ast, key);
    // get module.exports prop
    const root = ast
        .find(j.ObjectExpression)
        .filter((p) => {
        return (ast_utils_1.safeTraverse(p, ['parentPath', 'value', 'left', 'object', 'name']) === 'module' &&
            ast_utils_1.safeTraverse(p, ['parentPath', 'value', 'left', 'property', 'name']) === 'exports');
    })
        .filter((p) => !!p.value.properties);
    if (node.size() !== 0) {
        if (action === 'add') {
            return ast_utils_1.findRootNodesByName(j, root, key).forEach((p) => {
                j(p).replaceWith(ast_utils_1.addProperty(j, p, key, value, action));
            });
        }
        else if (action === 'remove') {
            return ast_utils_1.removeProperty(j, root, key, value);
        }
    }
    else {
        return root.forEach((p) => {
            if (value) {
                // init, add new property
                ast_utils_1.addProperty(j, p, key, value, null);
            }
        });
    }
}
exports.recursiveTransform = recursiveTransform;
exports.default = recursiveTransform;
