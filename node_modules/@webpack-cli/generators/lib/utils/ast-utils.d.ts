import { JSCodeshift, Node, valueType } from './types/NodePath';
/**
 *
 * Traverse safely over a path object for array for paths
 * @param {Object} obj - Object on which we traverse
 * @param {Array} paths - Array of strings containing the traversal path
 * @returns {Node} Value at given traversal path
 */
declare function safeTraverse(obj: Node, paths: string[]): Node | Node[];
/**
 *
 * Traverse safely and return `type` for path object with value.value property
 * @param {Node} path - AST node
 * @returns {String|Boolean} type at given path.
 */
declare function safeTraverseAndGetType(path: Node): string | boolean;
/**
 *
 * Find paths that match `new name.space.PluginName()` for a
 * given array of plugin names
 *
 * @param {any} j — jscodeshift API
 * @param {Node} node - Node to start search from
 * @param {String[]} pluginNamesArray - Array of plugin names like `webpack.LoaderOptionsPlugin`
 * @returns {Node} Node that has the pluginName
 */
declare function findPluginsByName(j: JSCodeshift, node: Node, pluginNamesArray: string[]): Node;
/**
 * It lookouts for the plugins property and, if the array is empty, it removes it from the AST
 * @param  {any} j - jscodeshift API
 * @param  {Node} rootNode - node to start search from
 * @returns {Node} rootNode modified AST.
 */
declare function findPluginsArrayAndRemoveIfEmpty(j: JSCodeshift, rootNode: Node): Node;
/**
 *
 * Finds the path to the `name: []` node
 *
 * @param {any} j — jscodeshift API
 * @param {Node} node - Node to start search from
 * @param {String} propName - property to search for
 * @returns {Node} found node and
 */
declare function findRootNodesByName(j: JSCodeshift, node: Node, propName: string): Node;
/**
 *
 * Creates an appropriate identifier or literal property
 *
 * @param {any} j — jscodeshift API
 * @param {String | Boolean | Number} val
 * @returns {Node}
 */
declare function createIdentifierOrLiteral(j: JSCodeshift, val: valueType): Node;
/**
 *
 * Creates an appropriate literal property
 *
 * @param {any} j — jscodeshift API
 * @param {String | Boolean | Number} val
 * @returns {Node}
 */
declare function createLiteral(j: JSCodeshift, val: valueType): Node;
/**
 *
 * Creates an Object's property with a given key and value
 *
 * @param {any} j — jscodeshift API
 * @param {String | Number} key - Property key
 * @param {String | Number | Boolean} value - Property value
 * @returns {Node}
 */
declare function createProperty(j: JSCodeshift, key: string | number, value: valueType): Node;
/**
 *
 * Adds or updates the value of a key within a root
 * webpack configuration property that's of type Object.
 *
 * @param {any} j — jscodeshift API
 * @param {Node} rootNode - node of root webpack configuration
 * @param {String} configProperty - key of an Object webpack configuration property
 * @param {String} key - key within the configuration object to update
 * @param {Object} value - the value to set for the key
 * @returns {Void}
 */
declare function addOrUpdateConfigObject(j: JSCodeshift, rootNode: Node, configProperty: string, key: string, value: valueType): void;
/**
 *
 * Finds and removes a node for a given plugin name. If the plugin
 * is the last in the plugins array, the array is also removed.
 *
 * @param {any} j — jscodeshift API
 * @param {Node} node - node to start search from
 * @param {String} pluginName - name of the plugin to remove
 * @returns {Node | Void} - path to the root webpack configuration object if plugin is found
 */
declare function findAndRemovePluginByName(j: JSCodeshift, node: Node, pluginName: string): Node;
/**
 *
 * Finds or creates a node for a given plugin name string with options object
 * If plugin declaration already exist, options are merged.
 *
 * @param {any} j — jscodeshift API
 * @param {Node} rootNodePath - `plugins: []` NodePath where plugin should be added.
 * 								See https://github.com/facebook/jscodeshift/wiki/jscodeshift-Documentation#nodepaths
 * @param {String} pluginName - ex. `webpack.LoaderOptionsPlugin`
 * @param {Object} options - plugin options
 * @returns {Void}
 */
declare function createOrUpdatePluginByName(j: JSCodeshift, rootNodePath: Node, pluginName: string, options?: object): void;
/**
 *
 * Finds the variable to which a third party plugin is assigned to
 *
 * @param {any} j — jscodeshift API
 * @param {Node} rootNode - `plugins: []` Root Node.
 * 							See https://github.com/facebook/jscodeshift/wiki/jscodeshift-Documentation#nodepaths
 * @param {String} pluginPackageName - ex. `extract-text-plugin`
 * @returns {String} variable name - ex. 'const s = require(s) gives "s"`
 */
declare function findVariableToPlugin(j: JSCodeshift, rootNode: Node, pluginPackageName: string): string;
/**
 *
 * Returns true if type is given type
 * @param {Node} path - AST node
 * @param {String} type - node type
 * @returns {Boolean}
 */
declare function isType(path: Node, type: string): boolean;
declare function findObjWithOneOfKeys(p: Node, keyNames: string[]): boolean;
/**
 *
 * Returns constructed require symbol
 * @param {any} j — jscodeshift API
 * @param {String} constName - Name of require
 * @param {String} packagePath - path of required package
 * @returns {Node} - the created ast
 */
declare function getRequire(j: JSCodeshift, constName: string, packagePath: string): Node;
/**
 *
 * Recursively adds an object/property to a node
 * @param {any} j — jscodeshift API
 * @param {Node} p - AST node
 * @param {String} key - key of a key/val object
 * @param {Any} value - Any type of object
 * @param {String} action - Action to be done on the given ast
 * @returns {Node} - the created ast
 */
declare function addProperty(j: JSCodeshift, p: Node, key: string, value: valueType, action?: string): Node;
/**
 *
 * Removes an object/property from the config
 * @param {any} j — jscodeshift API
 * @param {Node} ast - AST node
 * @param {String} key - key of a key/val object
 * @param {Any} value - Any type of object
 * @returns {Node} - the created ast
 */
declare function removeProperty(j: JSCodeshift, ast: Node, key: string, value: valueType): Node;
/**
 *
 * Get an property named topScope from yeoman and inject it to the top scope of
 * the config, outside module.exports
 *
 * @param j — jscodeshift API
 * @param ast - jscodeshift API
 * @param {any} value - transformation object to scaffold
 * @param {String} action - action that indicates what to be done to the AST
 * @returns ast - jscodeshift API
 */
declare function parseTopScope(j: JSCodeshift, ast: Node, value: string[], action: string): boolean | Node;
/**
 *
 * Transform for merge. Finds the merge property from yeoman and creates a way
 * for users to allow webpack-merge in their scaffold
 *
 * @param j — jscodeshift API
 * @param ast - jscodeshift API
 * @param {any} value - transformation object to scaffold
 * @param {String} action - action that indicates what to be done to the AST
 * @returns ast - jscodeshift API
 */
declare function parseMerge(j: JSCodeshift, ast: Node, value: string[], action: string): boolean | Node;
export { safeTraverse, safeTraverseAndGetType, createProperty, findPluginsByName, findRootNodesByName, addOrUpdateConfigObject, findAndRemovePluginByName, createOrUpdatePluginByName, findVariableToPlugin, findPluginsArrayAndRemoveIfEmpty, isType, createLiteral, createIdentifierOrLiteral, findObjWithOneOfKeys, getRequire, addProperty, removeProperty, parseTopScope, parseMerge, };
